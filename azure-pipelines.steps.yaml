parameters:
  os: ''


steps:
# - checkout: self
#   clean: true

- script: printenv | sort
  displayName: Dumps and sorts env variables

- script: |
    printf "parameters.os: $(parameters.os)"


- ${{ if eq(parameters.os, 'Linux') }}:

  - script: |
      printenv | sort
    displayName: Dumps and sorts env variables

  - script: |
      export PKG_VERSION=$(python3 -c 'import foobar; print(foobar.__version__)'); \
      export PKG_NAME=${PYTHON_VERSION}-${PKG_VERSION}; \
      echo "##vso[task.setvariable variable=packageVersion;isOutput=true]${PKG_VERSION}"
      echo "##vso[task.setvariable variable=packageBasename;isOutput=true]${PKG_NAME}"
    name: packageName
    workingDirectory: ./src
    failOnStderr: true
    displayName: Generate package and basenames

  - script: |
      docker build -t "$(imageName):$(packageName.packageBasename)" -f ./Dockerfile .
      docker tag "$(imageName):$(packageName.packageBasename)" "$(dockerRegistryEndpoint)/$(imageName):$(packageName.packageBasename)"
      docker push $(dockerRegistryEndpoint)/$(imageName):$(packageName.packageBasename)

      if [[ "${ISLATEST}" = "true" ]]; then \
        printf "this is the LATEST"; \
        docker tag "$(imageName):$(packageName.packageBasename)" "$(imageName):latest"
        docker tag "$(imageName):latest" "$(dockerRegistryEndpoint)/$(imageName):latest"; \
        docker push "$(dockerRegistryEndpoint)/$(imageName):latest"; \
      else \
        printf "not the LATEST"; \
      fi
    failOnStderr: true
    displayName: Docker tag and push with registry

